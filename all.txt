###########-base64_step.rs-############
#[allow(noop_method_call, unused_assignments)]
pub mod base64 {

    use crate::{pipeline_module::pipeline::{PipelineDirection, PipelineStep}, BoxedClone};
    use base64::{
        alphabet,
        engine::{general_purpose::NO_PAD, GeneralPurpose},
        Engine as _,
    };
    use std::{
        collections::VecDeque,
        io::{Read, Write},
    };

    pub const B64_ENGINE: GeneralPurpose = GeneralPurpose::new(&alphabet::BIN_HEX, NO_PAD);
    pub const NEW_LINE: &[u8] = &[b'\n'; 1];
    pub struct Base64 {
        forward_buffer: Vec<u8>,
        backward_buffer: Vec<u8>,
        work_mode: PipelineDirection,
        pipeline_direction: PipelineDirection,
    }

    impl PipelineStep for Base64 {
        fn len(&self) -> std::io::Result<usize> {
            // Ok(self.forward_buffer.len())
            match self.pipeline_direction {
                PipelineDirection::Forward => Ok(self.forward_buffer.len()),
                PipelineDirection::Backward => Ok(self.backward_buffer.len()),
            }
        }

        fn set_pipeline_direction(&mut self, direction: PipelineDirection) {
            self.pipeline_direction = direction;
        }

        fn start(&self) {}
    }

    impl BoxedClone for Base64 {
        fn bclone(&self) -> Box<dyn PipelineStep> {
            match self.work_mode {
                PipelineDirection::Forward => Box::new(Base64::new(Some("fw"))),
                PipelineDirection::Backward => Box::new(Base64::new(Some("bw"))),
            }
        }
    }

    impl Read for Base64 {
        fn read(&mut self, mut buf: &mut [u8]) -> std::io::Result<usize> {
            match self.pipeline_direction {
                PipelineDirection::Forward => {
                    let length = std::cmp::min(self.forward_buffer.len(), buf.len());
                    let size = buf.write(&self.forward_buffer[0..length]).unwrap();
                    self.forward_buffer.drain(0..size);
                    Ok(size)
                }
                PipelineDirection::Backward => {
                    let length = std::cmp::min(self.backward_buffer.len(), buf.len());
                    let size = buf.write(&self.backward_buffer[0..length]).unwrap();
                    self.backward_buffer.drain(0..size);
                    Ok(size)
                }
            }
        }
    }

    impl Write for Base64 {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let mut local_buf = buf.clone();
            if buf.ends_with(NEW_LINE) {
                local_buf = &buf[0..buf.len() - 1];
            }
            match self.pipeline_direction {
                PipelineDirection::Forward => {
                    if self.work_mode == self.pipeline_direction {
                        let b64 = B64_ENGINE.encode(local_buf);
                        let data: &[u8] = b64.as_bytes();
                        self.forward_buffer.extend(data);
                        Ok(data.len())
                    } else {
                        let b64 = B64_ENGINE.decode(local_buf).unwrap();
                        self.forward_buffer.extend(b64.as_slice());
                        Ok(b64.len())
                    }
                }
                PipelineDirection::Backward => {
                    if self.work_mode == self.pipeline_direction {
                        let b64 = B64_ENGINE.encode(local_buf);
                        let data: &[u8] = b64.as_bytes();
                        self.backward_buffer.extend(data);
                        Ok(data.len())
                    } else {
                        let s = std::str::from_utf8(local_buf).unwrap();
                        let b64 = B64_ENGINE.decode(s).unwrap();
                        self.backward_buffer.extend(b64.as_slice());
                        Ok(b64.len())
                    }
                }
            }
        }

        fn flush(&mut self) -> std::io::Result<()> {
            Ok(())
        }
    }

    impl Base64 {
        pub fn new(config: Option<&str>) -> Base64 {
            let mut work_mode: PipelineDirection = PipelineDirection::Forward;
            match config {
                Some("fw") => work_mode = PipelineDirection::Forward,
                Some("bw") => work_mode = PipelineDirection::Backward,
                Some(_) | None => {
                    panic!("Base64Encoder : Unknown Work Mode")
                }
            }
            Base64 {
                forward_buffer: vec![0; 0],
                backward_buffer: vec![0; 0],
                work_mode: work_mode,
                pipeline_direction: PipelineDirection::Forward,
            }
        }
    }
}



###########-entry_module.rs-############
pub mod entry_module {
    use std::{
        io::{Read, Write},
        net::TcpStream, os::fd::AsRawFd,
    };

    use crate::Pipeline;

    pub trait Entry : Clone {
        fn new(config: String, pipeline: Pipeline, loop_time: u64) -> Self;
        // fn len(&self) -> std::io::Result<usize>;
        // fn read(&mut self);
        // fn write(&mut self);
        fn len(stream: &mut dyn AsRawFd) -> std::io::Result<usize>;
        fn listen(&mut self);
    }
}



###########-lib.rs-############
mod entry_module;
pub use entry_module::entry_module::Entry;

mod websocket_entry;
pub use websocket_entry::websocket_entry::WebsocketEntry;

mod stdio_entry;
pub use stdio_entry::io_entry::STDioEntry;

mod tcp_entry;
pub use tcp_entry::tcp_entry::TCPEntry;

mod pipeline_module;
pub use pipeline_module::{
    pipeline::BoxedClone, pipeline::Pipeline, pipeline::PipelineDirection, pipeline::PipelineStep,
};

mod websocket_step;
pub use websocket_step::{ws_destination::WebsocketDestination, wss_destination::WssDestination};

mod stdio_step;
pub use stdio_step::io_step::STDioStep;

mod base64_step;
pub use base64_step::base64::Base64;

mod tcp_step;
pub use tcp_step::tcp_step::TCPStep;

mod random_salt_step;
pub use random_salt_step::random_salt_step::RSult;

mod tcp_entry_nonblocking;
pub use tcp_entry_nonblocking::tcp_entry_nonblocking::TcpEntryNonBlocking;

mod websocket_entry_nonblocking;
pub use websocket_entry_nonblocking::websocket_entry_nonblocking::WSEntryNonBlocking;


###########-main.rs-############
use openssl::conf;
use proxy::{
    Base64, Entry, Pipeline, PipelineStep, STDioEntry, STDioStep, TCPEntry, TCPStep,
    WebsocketDestination, WebsocketEntry, WssDestination, RSult, TcpEntryNonBlocking,
    WSEntryNonBlocking
};
use std::{
    str::FromStr,
    sync::{Arc, Mutex},
    thread,
    time::Duration,
};

const USAGE: &'static str = "
Usage: 
  proxy [OPTIONS]

Options:
  -e entry
  -s define step 
  -t loop_time(default is 10ms)          
  -h, --help     Print help

Entries:
  ws://
  stdio:
  tcp://

Steps:
  stdio:
  ws://
  b64:fw b64:bw
  tcp://
  salt:fw-len salf:bw-len
";

fn main() {
    let mut pargs = pico_args::Arguments::from_env();

    if pargs.contains(["-h", "--help"]) {
        print!("{}", USAGE);
        std::process::exit(0);
    }

    let mut steps: Vec<Box<dyn PipelineStep>> = Vec::new();
    loop {
        let step = pargs.opt_value_from_str::<&str, String>("-s").unwrap();
        if step == None {
            break;
        }
        let step = step.unwrap();
        println!("step : {step}");

        let res: Vec<String> = step.split(":").map(|s| s.to_string()).collect();
        let protocol = Some(res.get(0).unwrap().as_str());
        let config = Some(res.get(1).unwrap().as_str());
        match protocol {
            Some("stdio") => {
                steps.push(Box::new(STDioStep::new()));
            }
            Some("ws") => steps.push(Box::new(WebsocketDestination::new(step.as_str()))),
            Some("wss") => steps.push(Box::new(WssDestination::new(step.as_str()))),
            Some("b64") => steps.push(Box::new(Base64::new(config))),
            Some("tcp") => steps.push(Box::new(TCPStep::new(step.as_str()))),
            Some("salt") => steps.push(Box::new(RSult::new(config))),
            None | _ => {
                print!("unknown step : {}", step);
            }
        }
    }
    let pipeline = Pipeline::new(steps, Some(1024));

    let loop_time = pargs.opt_value_from_str::<&str, u64>("-t").unwrap();

    let entry = pargs.opt_value_from_str::<&str, String>("-e").unwrap();
    if entry == None {
        panic!("no entry defined");
    }
    let entry = entry.unwrap();
    println!("entry : {entry}");

    let res: Vec<String> = entry.split(":").map(|s| s.to_string()).collect();
    let protocol = Some(res.get(0).unwrap().as_str());
    let config = Some(res.get(1).unwrap().as_str());
    match protocol {
        Some("ws") => {
            let mut entry = WSEntryNonBlocking::new(entry, pipeline, loop_time.unwrap());
            entry.listen();
        }
        Some("stdio") => {
            let mut entry = STDioEntry::new(String::new(), pipeline, loop_time.unwrap());
            entry.listen();
        }
        Some("tcp") => {
            let mut entry = TcpEntryNonBlocking::new(entry, pipeline, loop_time.unwrap());
            entry.listen();
        }
        None | _ => {
            panic!("unknown entry : {}", entry);
        }
    }

    // let remaining = pargs.finish();
    // if !remaining.is_empty() {
    //     eprintln!("Warning: unused arguments left: {:?}.", remaining);
    // }
}



###########-pipeline_module.rs-############
// #[allow(non_snake_case, unused_variables, dead_code)]

pub mod pipeline {
    use std::{
        fmt::Display,
        io::{self, Read, Write},
        ops::{BitAnd, Deref, DerefMut},
        string::ParseError,
    };

    #[derive(Debug)]
    pub enum IOError {
        InvalidConnection,
        InvalidBindAddress,
        UnknownError(String),
        IoError(io::Error),
        ParseError(ParseError),
        InvalidStep(String),
    }

    pub trait BoxedClone {
        fn bclone(&self) -> Box<dyn PipelineStep>;
    }

    pub enum PipelineDirection {
        Forward = 0x01,
        Backward = 0x02,
    }

    impl Clone for PipelineDirection {
        fn clone(&self) -> Self {
            match self {
                Self::Forward => Self::Forward,
                Self::Backward => Self::Backward,
            }
        }
    }

    impl Copy for PipelineDirection {}

    impl PartialEq for PipelineDirection {
        fn eq(&self, other: &Self) -> bool {
            core::mem::discriminant(self) == core::mem::discriminant(other)
        }
    }

    impl Display for PipelineDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                PipelineDirection::Forward => write!(f, "PipelineDirection::Forward"),
                PipelineDirection::Backward => write!(f, "PipelineDirection::Backward"),
            }
        }
    }

    pub trait PipelineStep: Read + Write + Send + Sync + BoxedClone {
        fn start(&self);
        fn len(&self) -> std::io::Result<usize>;
        fn set_pipeline_direction(&mut self, direction: PipelineDirection);
    }

    pub struct Pipeline {
        steps: Vec<Box<dyn PipelineStep>>,
        buffer_size: Option<usize>,
    }

    impl Deref for Pipeline {
        type Target = [Box<dyn PipelineStep>];

        fn deref(&self) -> &Self::Target {
            &self.steps
        }
    }

    impl DerefMut for Pipeline {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.steps
        }
    }

    impl Clone for Pipeline {
        fn clone(&self) -> Self {
            let mut steps = Vec::<Box<dyn PipelineStep>>::new();
            for step in self.steps.as_slice() {
                steps.push(step.bclone())
            }
            Pipeline::new(steps, self.buffer_size)
        }
    }

    impl Pipeline {
        pub fn new(steps: Vec<Box<dyn PipelineStep>>, buffer_size: Option<usize>) -> Self {
            Pipeline {
                steps: steps,
                buffer_size: Some(buffer_size.unwrap_or(1024)),
            }
        }

        pub fn write(&mut self, mut data: Vec<u8>) -> Result<usize, IOError> {
            for i in 0..self.steps.len() {
                self.steps[i].set_pipeline_direction(PipelineDirection::Forward);
            }
            let mut size = 0;
            
            for i in 0..self.steps.len() {
                self.steps[i].write(&data).unwrap();
                self.steps[i].flush().unwrap();
                size = self.steps[i].len().unwrap();
                if i != (self.steps.len() - 1) {
                    data.clear();
                    data.resize(size, 0);
                    size = self.steps[i].read(data.as_mut_slice()).unwrap();
                }
            }
            Ok(size)
        }

        pub fn read(&mut self) -> Result<Vec<u8>, IOError> {
            for i in 0..self.steps.len() {
                self.steps[i].set_pipeline_direction(PipelineDirection::Backward);
            }

            let mut data: Vec<u8> = Vec::new();
            data.resize(self.buffer_size.unwrap(), 0);
            let mut size = 0;

            for i in (0..self.steps.len()).rev() {
                size = self.steps[i].len().unwrap();
                data.clear();
                data.resize(size, 0);
                size = self.steps[i].read(data.as_mut_slice()).unwrap();
                // self.steps[i].read(data.as_mut_slice()).unwrap();
                if size > 0 && i != 0 {
                    self.steps[i - 1].write(&data[0..size]).unwrap();
                    self.steps[i - 1].flush().unwrap();
                }
            }
            Ok(Vec::from(&data[0..size]))
        }

        pub fn read_available(&self) -> bool {
            self.steps.last().unwrap().len().unwrap() != 0
        }
    }
}



###########-random_salt_step.rs-############
#[allow(noop_method_call, unused_assignments)]
pub mod random_salt_step {
    use crate::{
        pipeline_module::pipeline::{PipelineDirection, PipelineStep},
        BoxedClone,
    };
    use openssl::string;
    use rand::Rng;
    use std::{
        collections::VecDeque,
        io::{Read, Write},
    };

    pub struct RSult {
        salt_lengh: usize,
        forward_buffer: Vec<u8>,
        backward_buffer: Vec<u8>,
        work_mode: PipelineDirection,
        pipeline_direction: PipelineDirection,
    }

    impl PipelineStep for RSult {
        fn len(&self) -> std::io::Result<usize> {
            // Ok(self.forward_buffer.len())
            match self.pipeline_direction {
                PipelineDirection::Forward => Ok(self.forward_buffer.len()),
                PipelineDirection::Backward => Ok(self.backward_buffer.len()),
            }
        }

        fn set_pipeline_direction(&mut self, direction: PipelineDirection) {
            self.pipeline_direction = direction;
        }

        fn start(&self) {}
    }

    impl BoxedClone for RSult {
        fn bclone(&self) -> Box<dyn PipelineStep> {
            let mut config : String = String::new();
            match self.work_mode {
                PipelineDirection::Forward => config.push_str("fw-"),
                PipelineDirection::Backward => config.push_str("bw-"),
            }
            config.push_str(self.salt_lengh.to_string().as_str());
            Box::new(RSult::new(Some(config.as_str())))
        }
    }

    impl Read for RSult {
        fn read(&mut self, mut buf: &mut [u8]) -> std::io::Result<usize> {
            match self.pipeline_direction {
                PipelineDirection::Forward => {
                    let length = std::cmp::min(self.forward_buffer.len(), buf.len());
                    let size = buf.write(&self.forward_buffer[0..length]).unwrap();
                    self.forward_buffer.drain(0..size);
                    Ok(size)
                }
                PipelineDirection::Backward => {
                    let length = std::cmp::min(self.backward_buffer.len(), buf.len());
                    let size = buf.write(&self.backward_buffer[0..length]).unwrap();
                    self.backward_buffer.drain(0..size);
                    Ok(size)
                }
            }
        }
    }

    impl Write for RSult {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            match self.pipeline_direction {
                PipelineDirection::Forward => {
                    if self.work_mode == self.pipeline_direction {
                        let mut rng = rand::thread_rng();
                        let mut rbytes = vec![0u8; self.salt_lengh as usize];
                        rng.fill(rbytes.as_mut_slice());
                        self.forward_buffer.extend(rbytes);
                        self.forward_buffer.extend(buf);
                        Ok(self.forward_buffer.len())
                    } else {
                        self.forward_buffer.extend(buf[self.salt_lengh..].to_vec());
                        Ok(buf.len() - self.salt_lengh)
                        // self.forward_buffer.extend(buf);
                        // Ok(buf.len())
                    }
                }
                PipelineDirection::Backward => {
                    if self.work_mode == self.pipeline_direction {
                        let mut rng = rand::thread_rng();
                        let mut rbytes = vec![0u8; self.salt_lengh as usize];
                        rng.fill(rbytes.as_mut_slice());
                        self.backward_buffer.extend(rbytes);
                        self.backward_buffer.extend(buf);
                        Ok(self.backward_buffer.len())
                    } else {
                        self.backward_buffer.extend(buf[self.salt_lengh..].to_vec());
                        Ok(buf.len() - self.salt_lengh)
                        // self.backward_buffer.extend(buf);
                        // Ok(buf.len())
                    }
                }
            }
        }

        fn flush(&mut self) -> std::io::Result<()> {
            Ok(())
        }
    }

    impl RSult {
        pub fn new(config: Option<&str>) -> RSult {
            let mut work_mode: PipelineDirection = PipelineDirection::Forward;
            let mut salt_length: usize = 0;

            match config {
                Some(value) => {
                    let config: Vec<String> = value.split("-").map(|s| s.to_string()).collect();
                    if config.len() != 2 {
                        panic!("random_salt_step: invalid config ");
                    } else {
                        match config[0].as_str() {
                            "fw" => work_mode = PipelineDirection::Forward,
                            "bw" => work_mode = PipelineDirection::Backward,
                            _ => {
                                panic!("random_salt_step : Unknown Work Mode")
                            }
                        }

                        match config[1].parse::<usize>() {
                            Ok(value) => {
                                salt_length = value;
                            }
                            Err(e) => {
                                panic!("random_salt_step: salt length error : {}", e);
                            }
                        }
                    }
                }
                None => {
                    panic!("random_salt_step : Empty Config")
                }
            }

            RSult {
                salt_lengh: salt_length,
                forward_buffer: vec![0; 0],
                backward_buffer: vec![0; 0],
                work_mode: work_mode,
                pipeline_direction: PipelineDirection::Forward,
            }
        }
    }
}



###########-stdio_entry.rs-############
pub mod io_entry {
    use crate::{
        pipeline_module::pipeline::{PipelineDirection, PipelineStep},
        BoxedClone, Entry, Pipeline,
    };
    use std::{
        io::{stdin, stdout, Read, Write},
        os::fd::AsRawFd,
        thread,
        time::Duration,
    };

    pub struct STDioEntry {
        pipeline: Pipeline,
        loop_time: u64,
    }

    impl Entry for STDioEntry {
        fn len(stream: &mut dyn AsRawFd) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn new(config: String, pipeline: crate::Pipeline, loop_time: u64) -> Self {
            STDioEntry { pipeline: pipeline, loop_time: loop_time }
        }

        fn listen(&mut self) {
            loop {
                let len = STDioEntry::len(&mut std::io::stdin()).unwrap();
                if len > 0 {
                    let mut buf: Vec<u8> = vec![0; len];
                    self.read(buf.as_mut_slice()).unwrap();
                    self.pipeline.write(buf).unwrap();
                }

                if self.pipeline.read_available() {
                    let mut data = self.pipeline.read().unwrap();
                    if data.len() > 0 {
                        self.write(&data.as_mut_slice()).unwrap();
                        self.flush().unwrap();
                    }
                }
                thread::sleep(Duration::from_millis(self.loop_time));
            }
        }
    }

    impl Clone for STDioEntry {
        fn clone(&self) -> STDioEntry {
            STDioEntry {
                pipeline: self.pipeline.clone(),
                loop_time: self.loop_time
            }
        }
    }

    impl Read for STDioEntry {
        fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
            let mut io = stdin();
            let mut available: usize = 0;
            let result: i32 = unsafe { libc::ioctl(0, libc::FIONREAD, &mut available) };

            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else if available == 0 {
                Ok(0)
            } else {
                io.read(buf)
            }
        }
    }

    impl Write for STDioEntry {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let mut io = stdout();
            io.write(buf)
        }

        fn flush(&mut self) -> std::io::Result<()> {
            let mut io = stdout();
            io.flush()
        }
    }
}



###########-stdio_step.rs-############
pub mod io_step {
    use crate::{
        pipeline_module::pipeline::{PipelineDirection, PipelineStep},
        BoxedClone,
    };
    use std::io::{stdin, stdout, Read, Write};

    pub struct STDioStep {}

    impl PipelineStep for STDioStep {
        fn len(&self) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 = unsafe { libc::ioctl(0, libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        #[allow(unused_variables)]
        fn set_pipeline_direction(&mut self, direction: PipelineDirection) {}

        fn start(&self) {}
    }

    impl BoxedClone for STDioStep {
        fn bclone(&self) -> Box<dyn PipelineStep> {
            Box::new(STDioStep::new())
        }
    }

    impl Default for STDioStep {
        fn default() -> Self {
            Self {}
        }
    }

    impl Read for STDioStep {
        fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
            let mut io = stdin();
            let mut available: usize = 0;
            let result: i32 = unsafe { libc::ioctl(0, libc::FIONREAD, &mut available) };

            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else if available == 0 {
                Ok(0)
            } else {
                io.read(buf)
            }
        }
    }

    impl Write for STDioStep {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let mut io = stdout();
            io.write(buf)
        }

        fn flush(&mut self) -> std::io::Result<()> {
            let mut io = stdout();
            io.flush()
        }
    }

    impl STDioStep {
        pub fn new() -> STDioStep {
            STDioStep {}
        }
    }
}



###########-stream_step.rs-############
// pub mod stream_step {
//     use std::marker::{Send, Sync};
//     use std::{io::Read, io::Write, os::fd::AsRawFd};
//     use crate::{PipelineDirection, PipelineStep};

//     pub struct StreamStep<T>
//     where
//         T: Read + Write + AsRawFd + Send + Sync,
//     {
//         stream: T,
//         pipeline_direction: PipelineDirection,
//     }

//     impl<T> StreamStep<T>
//     where
//         T: Read + Write + AsRawFd + Send + Sync,
//     {
//         pub fn new(stream: T) -> Self {
//             Self {
//                 stream: stream,
//                 pipeline_direction: PipelineDirection::Forward,
//             }
//         }
//     }

//     impl<T> PipelineStep for StreamStep<T>
//     where
//         T: Read + Write + AsRawFd + Send + Sync,
//     {
//         fn len(&self) -> std::io::Result<usize> {
//             let mut available: usize = 0;
//             let result: i32 =
//                 unsafe { libc::ioctl(self.stream.as_raw_fd(), libc::FIONREAD, &mut available) };
//             if result == -1 {
//                 let errno = std::io::Error::last_os_error();
//                 Err(errno)
//             } else {
//                 Ok(available)
//             }
//         }

//         fn set_pipeline_direction(&mut self, direction: PipelineDirection) {
//             self.pipeline_direction = direction
//         }
        
//         fn start(&self) {
            
//         }
//     }

//     impl<T> Read for StreamStep<T>
//     where
//         T: Read + Write + AsRawFd + Send + Sync,
//     {
//         fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
//             self.stream.read(buf)
//         }
//     }

//     impl<T> Write for StreamStep<T>
//     where
//         T: Read + Write + AsRawFd + Send + Sync,
//     {
//         fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
//             self.stream.write(buf)
//         }

//         fn flush(&mut self) -> std::io::Result<()> {
//             self.stream.flush()
//         }
//     }
// }



###########-tcp_entry_nonblocking.rs-############
pub mod tcp_entry_nonblocking {
    use crate::{Entry, Pipeline};
    use http::Uri;
    use polling::{Event, Events, Poller};
    use regex::Regex;
    use std::collections::HashMap;
    use std::io::{self, Read, Write};
    use std::net::{SocketAddr, TcpListener, TcpStream};
    use std::os::fd::AsRawFd;
    use std::thread;
    use std::time::Duration;

    pub struct TcpEntryNonBlocking {
        poller: Poller,
        listener: TcpListener,
        listener_key: usize,
        connections: HashMap<usize, (TcpStream, SocketAddr)>,
        pipeline: Pipeline,
        loop_time: u64,
    }

    impl Entry for TcpEntryNonBlocking {
        fn new(config: String, pipeline: Pipeline, loop_time: u64) -> Self {
            let re = Regex::new(r"((https|wss|ws|http)?:\/\/)([^:/$]{1,})(?::(\d{1,}))").unwrap();
            if !re.is_match(&config) {
                panic!(
                    "unsupported config : {}. use with this format ws://host:port ",
                    config
                )
            }

            let uri: Uri = config.parse::<Uri>().unwrap();
            let mut addr = String::from(uri.host().unwrap());
            addr.push_str(":");
            addr.push_str(uri.port().unwrap().as_str());
            let mut listener = TcpListener::bind(addr).unwrap();
            let poller = Poller::new().unwrap();

            unsafe {
                poller.add(&listener, Event::readable(1)).unwrap();
            }

            TcpEntryNonBlocking {
                poller,
                listener,
                listener_key: 1,
                connections: HashMap::new(),
                pipeline: pipeline,
                loop_time,
            }
        }

        fn len(stream: &mut dyn AsRawFd) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn listen(&mut self) {
            let mut events = Events::new();

            loop {
                self.poller.wait(&mut events, None).unwrap();

                for ev in events.iter() {
                    if ev.key == self.listener_key {
                        let (client, client_address) = self.listener.accept().unwrap();
                        let client_key = self.connections.len() + self.listener_key;

                        println!("new client : {}", client_address);
                        self.connections
                            .insert(client_key, (client, client_address));

                        self.poller
                            .modify(&self.listener, Event::readable(self.listener_key))
                            .unwrap();

                        let mut cloned_self = self.clone();
                        thread::spawn(move || {
                            cloned_self.handle_connection(ev).unwrap();
                        });
                    }
                }
            }
        }
    }

    impl Clone for TcpEntryNonBlocking {
        fn clone(&self) -> Self {
            let mut connections = HashMap::new();
            for data in self.connections.iter() {
                connections.insert(data.0.clone(), (data.1 .0.try_clone().unwrap(), data.1 .1));
            }
            Self {
                poller: Poller::new().unwrap(),
                listener: self.listener.try_clone().unwrap(),
                listener_key: self.listener_key.clone(),
                connections: connections,
                pipeline: self.pipeline.clone(),
                loop_time: self.loop_time,
            }
        }
    }

    impl TcpEntryNonBlocking {
        fn handle_connection(&mut self, event: Event) -> io::Result<()> {
            let client = self.connections.get_mut(&event.key).unwrap();

            unsafe {
                self.poller.add(&client.0, Event::all(event.key))?;
            }
            let mut events = Events::new();

            loop {
                self.poller.wait(&mut events, None).unwrap();

                for ev in events.iter() {
                    if ev.key == event.key {
                        if ev.readable {
                            match TcpEntryNonBlocking::len(&mut client.0) {
                                Ok(len) => {
                                    if len > 0 {
                                        let mut buf = vec![0; len];
                                        match client.0.read_exact(&mut buf) {
                                            Ok(_) => {
                                                let len = buf.len();
                                                let final_size = self.pipeline.write(buf).unwrap();
                                            }
                                            Err(e) => {
                                                println!("Error reading from stream: {}", e);
                                            }
                                        }
                                    }
                                }
                                Err(e) => {
                                    println!("Error reading from stream: {}", e);
                                }
                            }
                        }

                        if ev.writable {
                            if self.pipeline.read_available() {
                                let data = self.pipeline.read().unwrap();
                                if !data.is_empty() {
                                    match client.0.write_all(&data) {
                                        Ok(_) => {}
                                        Err(e) => {
                                            println!("Error writing to stream: {}", e);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                self.poller
                    .modify(&client.0, Event::all(event.key))
                    .unwrap();
            }

            Ok(())
        }
    }
}



###########-tcp_entry.rs-############
pub mod tcp_entry {
    use libc::c_int;
    use regex::Regex;
    use std::io;
    use std::str::{self, FromStr};
    use std::{
        io::{Read, Write},
        net::{TcpListener, TcpStream},
        os::fd::AsRawFd,
        thread,
        time::Duration,
    };
    use tungstenite::http::Uri;

    use crate::{Entry, Pipeline};

    pub struct TCPEntry {
        tcp_server: TcpListener,
        address: String,
        pipeline: Pipeline,
        loop_time: u64,
    }

    impl Clone for TCPEntry {
        fn clone(&self) -> Self {
            Self {
                tcp_server: self.tcp_server.try_clone().unwrap(),
                address: self.address.clone(),
                pipeline: self.pipeline.clone(),
                loop_time: self.loop_time
            }
        }
    }

    impl Entry for TCPEntry {
        fn new(config: String, pipeline: crate::Pipeline, loop_time: u64) -> Self {
            let re = Regex::new(r"((https|wss|ws|http)?:\/\/)([^:/$]{1,})(?::(\d{1,}))").unwrap();
            if !re.is_match(&config) {
                panic!(
                    "unsupported config : {}. use with this format ws://host:port ",
                    config
                )
            }

            let uri: Uri = config.parse::<Uri>().unwrap();
            let mut addr = String::from(uri.host().unwrap());
            addr.push_str(":");
            addr.push_str(uri.port().unwrap().as_str());
            let server = TcpListener::bind(addr.clone()).unwrap();
            // server.set_nonblocking(true).expect("Cannot set non-blocking");

            TCPEntry {
                tcp_server: server,
                address: config,
                pipeline: pipeline,
                loop_time: loop_time
            }
        }

        fn len(stream: &mut dyn AsRawFd) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn listen(&mut self) {
            for conn in self.tcp_server.incoming() {
                match conn {
                    Ok(conn) => {
                        println!("new client : {}", conn.peer_addr().unwrap());

                        let mut cloned_self = self.clone();

                        let read_write_thread = thread::spawn(move || {
                            cloned_self.handle_pipeline(conn);
                        });
                    }
                    Err(e) => {
                        println!("{}", e)
                    }
                }
            }
        }
    }

    impl TCPEntry {
        fn is_tcp_connection_alive(&self, stream: &TcpStream) -> io::Result<bool> {
            let raw_fd = stream.as_raw_fd();

            // Call ioctl with SIOCOUTQ to get the amount of unsent data in the socket's output buffer
            let mut outq: c_int = 0;
            let res = unsafe { libc::ioctl(raw_fd, libc::SIOCOUTQNSD, &mut outq) };

            if res == -1 {
                // Error occurred while calling ioctl
                Err(io::Error::last_os_error())
            } else {
                // If there is unsent data in the output buffer, the connection is still alive
                Ok(outq > 0)
            }
        }

        fn handle_pipeline(&mut self, mut stream: TcpStream) {
            loop {
                // match self.is_tcp_connection_alive(&stream) {
                //     Ok(result) => {

                //     },
                //     Err(e) => {
                //         println!("{e}");
                //         break;
                //     },
                // }

                match TCPEntry::len(&mut stream) {
                    Ok(len) => {
                        if len > 0 {
                            let mut buf = vec![0; len];
                            match stream.read_exact(&mut buf) {
                                Ok(_) => {
                                    let len = buf.len();
                                    let final_size = self.pipeline.write(buf).unwrap();
                                }
                                Err(e) => {
                                    println!("Error reading from stream: {}", e);
                                    break;
                                }
                            }
                        }
                    }
                    Err(e) => {
                        println!("Error reading from stream: {}", e);
                    }
                }

                // std::thread::sleep(Duration::from_millis(10));

                if self.pipeline.read_available() {
                    let data = self.pipeline.read().unwrap();
                    if !data.is_empty() {
                        match stream.write_all(&data) {
                            Ok(_) => {}
                            Err(e) => {
                                println!("Error writing to stream: {}", e);
                                break;
                            }
                        }
                    }
                }

                std::thread::sleep(Duration::from_millis(self.loop_time));
            }
        }
    }
}



###########-tcp_step.rs-############
#[allow(non_snake_case, unused_variables, dead_code)]
pub mod tcp_step {
    use std::io::{Read, Write};
    use std::net::TcpStream;
    use std::os::fd::AsRawFd;
    use std::str::FromStr;
    use tungstenite::client::IntoClientRequest;
    use tungstenite::http::{Request, Uri};
    use tungstenite::protocol::{Role, WebSocketContext};
    use tungstenite::{client, Message, WebSocket};

    use crate::pipeline_module::pipeline::{PipelineDirection, PipelineStep};
    use crate::BoxedClone;

    pub struct TCPStep {
        tcp_stream: TcpStream,
        address: String,
    }

    impl PipelineStep for TCPStep {
        fn len(&self) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(self.tcp_stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn set_pipeline_direction(&mut self, direction: PipelineDirection) {
            // println!("{}", direction);
        }

        fn start(&self) {}
    }

    impl BoxedClone for TCPStep {
        fn bclone(&self) -> Box<dyn PipelineStep> {
            Box::new(TCPStep::new(&self.address))
        }
    }

    impl Read for TCPStep {
        fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(self.tcp_stream.as_raw_fd(), libc::FIONREAD, &mut available) };

            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else if available == 0 {
                Ok(0)
            } else {
                self.tcp_stream.read(buf)
            }
        }
    }

    impl Write for TCPStep {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            self.tcp_stream.write(buf)
        }

        fn flush(&mut self) -> std::io::Result<()> {
            self.tcp_stream.flush()
        }
    }

    #[allow(unreachable_code)]
    impl TCPStep {
        pub fn new(address: &str) -> Self {
            let mut connection: Option<TcpStream> = None;

            let uri: Uri = address.parse::<Uri>().unwrap();
            let mut addr = String::from(uri.host().unwrap());
            let port = uri.port().unwrap().as_u16();

            addr.push_str(":");
            addr.push_str(port.to_string().as_str());
            let connection = TcpStream::connect(addr).unwrap();

            //handle errors
            TCPStep {
                tcp_stream: connection,
                address: String::from_str(address).unwrap(),
            }
        }
    }
}


###########-websocket_entry_nonblocking.rs-############
pub mod websocket_entry_nonblocking {
    use crate::{Entry, Pipeline};
    use bytes::{self, BytesMut};
    use http::{Request, Response};
    use openssl::sha::Sha1;
    use polling::{Event, Events, Poller};
    use regex::Regex;
    use std::collections::HashMap;
    use std::io::{self, Read, Write};
    use std::net::{SocketAddr, TcpListener, TcpStream};
    use std::os::fd::AsRawFd;
    use std::str;
    use std::thread;
    use tokio_util::codec::{Decoder, Encoder};
    use tungstenite::protocol::Role;
    use tungstenite::{
        accept,
        error::ProtocolError,
        handshake::{server, MidHandshake},
        http::Uri,
        stream, Error, Message, WebSocket,
    };
    use websocket_codec::{self, MessageCodec};

    pub struct WSEntryNonBlocking {
        poller: Poller,
        address: String,
        listener: TcpListener,
        listener_key: usize,
        connections: HashMap<usize, (TcpStream, SocketAddr)>,
        pipeline: Pipeline,
        loop_time: u64,
    }

    impl Entry for WSEntryNonBlocking {
        fn new(config: String, pipeline: Pipeline, loop_time: u64) -> Self {
            let re = Regex::new(r"((https|wss|ws|http)?:\/\/)([^:/$]{1,})(?::(\d{1,}))").unwrap();
            if !re.is_match(&config) {
                panic!(
                    "unsupported config : {}. use with this format ws://host:port ",
                    config
                )
            }

            let uri: Uri = config.parse::<Uri>().unwrap();
            let mut addr = String::from(uri.host().unwrap());
            addr.push_str(":");
            addr.push_str(uri.port().unwrap().as_str());
            let mut listener = TcpListener::bind(addr).unwrap();
            // listener.set_nonblocking(true).unwrap();
            let poller = Poller::new().unwrap();

            unsafe {
                poller.add(&listener, Event::readable(1)).unwrap();
            }

            WSEntryNonBlocking {
                poller,
                address: config,
                listener,
                listener_key: 1,
                connections: HashMap::new(),
                pipeline: pipeline,
                loop_time,
            }
        }

        fn len(stream: &mut dyn AsRawFd) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn listen(&mut self) {
            let mut events = Events::new();

            loop {
                self.poller.wait(&mut events, None).unwrap();

                for ev in events.iter() {
                    if ev.key == self.listener_key {
                        let (client, client_address) = self.listener.accept().unwrap();

                        // client.set_nonblocking(true).unwrap();
                        let client_key = self.connections.len() + self.listener_key;
                        self.connections
                            .insert(client_key, (client, client_address));
                        let mut cloned_self = self.clone();

                        thread::spawn(move || {
                            cloned_self.handle_connection(ev);
                        });

                        self.poller
                            .modify(&self.listener, Event::readable(self.listener_key))
                            .unwrap();
                    }
                }
            }
        }
    }

    impl Clone for WSEntryNonBlocking {
        fn clone(&self) -> Self {
            let mut connections = HashMap::new();
            for data in self.connections.iter() {
                connections.insert(data.0.clone(), (data.1 .0.try_clone().unwrap(), data.1 .1));
            }
            Self {
                poller: Poller::new().unwrap(),
                address: self.address.clone(),
                listener: self.listener.try_clone().unwrap(),
                listener_key: self.listener_key.clone(),
                connections: connections,
                pipeline: self.pipeline.clone(),
                loop_time: self.loop_time,
            }
        }
    }

    impl WSEntryNonBlocking {
        fn handle_protocol_error(&self, error: ProtocolError, mut stream: TcpStream) {
            match error {
                tungstenite::error::ProtocolError::WrongHttpMethod => println!("WrongHttpMethod"),
                tungstenite::error::ProtocolError::WrongHttpVersion => println!("WrongHttpVersion"),
                tungstenite::error::ProtocolError::MissingConnectionUpgradeHeader => {
                    println!("MissingConnectionUpgradeHeader");
                    // let response = tungstenite::http::Response::new("Only WebSocket connections are welcome here");
                    let response = Response::builder()
                        .status(400)
                        //  .header("X-Custom-Foo", "Bar")
                        .body("Only WebSocket connections are welcome here")
                        .unwrap();
                    tungstenite::handshake::server::write_response(stream, &response).unwrap();
                }
                tungstenite::error::ProtocolError::MissingUpgradeWebSocketHeader => {
                    println!("MissingUpgradeWebSocketHeader")
                }
                tungstenite::error::ProtocolError::MissingSecWebSocketVersionHeader => {
                    println!("MissingSecWebSocketVersionHeader")
                }
                tungstenite::error::ProtocolError::MissingSecWebSocketKey => {
                    println!("MissingSecWebSocketKey")
                }
                tungstenite::error::ProtocolError::SecWebSocketAcceptKeyMismatch => {
                    println!("SecWebSocketAcceptKeyMismatch")
                }
                tungstenite::error::ProtocolError::JunkAfterRequest => println!("JunkAfterRequest"),
                tungstenite::error::ProtocolError::CustomResponseSuccessful => {
                    println!("CustomResponseSuccessful")
                }
                tungstenite::error::ProtocolError::InvalidHeader(_) => println!("InvalidHeader"),
                tungstenite::error::ProtocolError::HandshakeIncomplete => {
                    println!("HandshakeIncomplete")
                }
                tungstenite::error::ProtocolError::HttparseError(_) => println!("HttparseError"),
                tungstenite::error::ProtocolError::SendAfterClosing => println!("SendAfterClosing"),
                tungstenite::error::ProtocolError::ReceivedAfterClosing => {
                    println!("ReceivedAfterClosing")
                }
                tungstenite::error::ProtocolError::NonZeroReservedBits => {
                    println!("NonZeroReservedBits")
                }
                tungstenite::error::ProtocolError::UnmaskedFrameFromClient => {
                    println!("UnmaskedFrameFromClient")
                }
                tungstenite::error::ProtocolError::MaskedFrameFromServer => {
                    println!("MaskedFrameFromServer")
                }
                tungstenite::error::ProtocolError::FragmentedControlFrame => {
                    println!("FragmentedControlFrame")
                }
                tungstenite::error::ProtocolError::ControlFrameTooBig => {
                    println!("ControlFrameTooBig")
                }
                tungstenite::error::ProtocolError::UnknownControlFrameType(_) => {
                    println!("UnknownControlFrameType")
                }
                tungstenite::error::ProtocolError::UnknownDataFrameType(_) => {
                    println!("UnknownDataFrameType")
                }
                tungstenite::error::ProtocolError::UnexpectedContinueFrame => {
                    println!("UnexpectedContinueFrame")
                }
                tungstenite::error::ProtocolError::ExpectedFragment(_) => {
                    println!("ExpectedFragment")
                }
                tungstenite::error::ProtocolError::ResetWithoutClosingHandshake => {
                    println!("ResetWithoutClosingHandshake")
                }
                tungstenite::error::ProtocolError::InvalidOpcode(_) => println!("InvalidOpcode"),
                tungstenite::error::ProtocolError::InvalidCloseSequence => {
                    println!("InvalidCloseSequence")
                }
            }
        }

        fn handle_handshake_error(&self, error: Error, mut stream: TcpStream) {
            match error {
                tungstenite::Error::ConnectionClosed => {
                    println!("ConnectionClosed");
                }
                tungstenite::Error::AlreadyClosed => {
                    println!("AlreadyClosed");
                }
                tungstenite::Error::Io(_) => {
                    println!("Io");
                }
                tungstenite::Error::Tls(_) => {
                    println!("Tls");
                }
                tungstenite::Error::Capacity(_) => {
                    println!("Capacity");
                }
                tungstenite::Error::Protocol(protocol) => {
                    self.handle_protocol_error(protocol, stream);
                }
                tungstenite::Error::WriteBufferFull(_) => {
                    println!("WriteBufferFull");
                }
                tungstenite::Error::Utf8 => {
                    println!("Utf8");
                }
                tungstenite::Error::AttackAttempt => {
                    println!("AttackAttempt");
                }
                tungstenite::Error::Url(_) => {
                    println!("Url");
                }
                tungstenite::Error::Http(_) => {
                    println!("Http");
                }
                tungstenite::Error::HttpFormat(_) => {
                    println!("HttpFormat");
                }
            }
        }

        fn handshake(mut stream: TcpStream) {
            let mut buffer = [0; 1024];
            let read_size = stream.read(&mut buffer).unwrap();

            // Parse the HTTP request
            let request = Request::builder().body(()).unwrap();
            let request_str = str::from_utf8(&buffer[..read_size]).unwrap();
            println!("request : {} ", request_str);
            let headers: Vec<&str> = request_str.split("\r\n").collect();
            let mut websocket_key = String::new();

            for header in headers {
                if header.starts_with("Sec-WebSocket-Key:") {
                    websocket_key = header.split(": ").nth(1).unwrap().to_string();
                    break;
                }
            }

            if websocket_key.is_empty() {
                eprintln!("WebSocket key not found in headers");
                return;
            }

            // Create WebSocket accept key
            let magic_string = websocket_key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            let mut hasher = Sha1::new();
            hasher.update(magic_string.as_bytes());
            let result = hasher.finish();
            let accept_key = base64::encode(result);

            // Send WebSocket handshake response
            let response = format!(
                "HTTP/1.1 101 Switching Protocols\r\n\
                         Connection: Upgrade\r\n\
                         Upgrade: websocket\r\n\
                         Sec-WebSocket-Accept: {}\r\n\r\n",
                accept_key
            );
            stream.write_all(response.as_bytes()).unwrap();
            stream.flush().unwrap();
        }

        fn handle_connection(&mut self, event: Event) {
            let client = self.connections.get_mut(&event.key).unwrap();
            client.0.set_nonblocking(true).unwrap();


            unsafe {
                self.poller.add(&client.0, Event::all(event.key)).unwrap();
            }
            let mut events = Events::new();

            let mut handhsaked = false;

            loop {
                self.poller.wait(&mut events, None).unwrap();

                for ev in events.iter() {
                    if ev.key == event.key {
                        if ev.readable {
                            if !handhsaked {
                                WSEntryNonBlocking::handshake(client.0.try_clone().unwrap());
                                handhsaked = true;
                                continue;
                            }
                            match WSEntryNonBlocking::len(&mut client.0) {
                                Ok(len) => {
                                    if len > 0 {
                                        let mut buf: BytesMut = BytesMut::new();
                                        buf.resize(len, 0u8);
                                        client.0.read(buf.as_mut()).unwrap();
                                        let mut msgc = websocket_codec::MessageCodec::server()
                                            .decode(&mut buf)
                                            .unwrap();

                                        match &mut msgc {
                                            Some(msg) => match msg.opcode() {
                                                websocket_codec::Opcode::Text
                                                | websocket_codec::Opcode::Binary => {
                                                    self.pipeline
                                                        .write(msg.data().to_vec())
                                                        .unwrap();
                                                }
                                                websocket_codec::Opcode::Close => {
                                                    break;
                                                }
                                                websocket_codec::Opcode::Ping
                                                | websocket_codec::Opcode::Pong => {}
                                            },
                                            None => {}
                                        }
                                    }
                                }
                                Err(e) => {
                                    println!("Error reading from stream: {}", e);
                                }
                            }
                        }

                        if ev.writable {
                            if self.pipeline.read_available() {
                                let data = self.pipeline.read().unwrap();
                                if !data.is_empty() {
                                    let msg = Message::Binary(data);

                                    if let Err(e) = client.0.write(msg.into_data().as_slice()) {
                                        println!("Error writing to stream: {}", e);
                                        break;
                                    }
                                    if let Err(e) = client.0.flush() {
                                        println!("Error flush stream: {}", e);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                self.poller
                    .modify(&client.0, Event::all(event.key))
                    .unwrap();
            }
        }
    }
}



###########-websocket_entry.rs-############
pub mod websocket_entry {
    use http::Response;
    use regex::Regex;
    use std::{
        io::{Read, Write},
        net::{TcpListener, TcpStream},
        os::fd::AsRawFd,
        thread,
        time::Duration,
    };
    use tungstenite::{
        accept,
        error::ProtocolError,
        handshake::{server, MidHandshake},
        http::Uri,
        stream, Error, Message, WebSocket,
    };

    use crate::{Entry, Pipeline};

    pub struct WebsocketEntry {
        tcp_server: TcpListener,
        address: String,
        pipeline: Pipeline,
        loop_time: u64,
    }

    impl Clone for WebsocketEntry {
        fn clone(&self) -> Self {
            Self {
                tcp_server: self.tcp_server.try_clone().unwrap(),
                address: self.address.clone(),
                pipeline: self.pipeline.clone(),
                loop_time: self.loop_time,
            }
        }
    }

    impl Entry for WebsocketEntry {
        fn new(config: String, pipeline: crate::Pipeline, loop_time: u64) -> Self {
            let re = Regex::new(r"((https|wss|ws|http)?:\/\/)([^:/$]{1,})(?::(\d{1,}))").unwrap();
            if !re.is_match(&config) {
                panic!(
                    "unsupported config : {}. use with this format ws://host:port ",
                    config
                )
            }

            let uri: Uri = config.parse::<Uri>().unwrap();
            let mut addr = String::from(uri.host().unwrap());
            addr.push_str(":");
            addr.push_str(uri.port().unwrap().as_str());
            let server = TcpListener::bind(addr.clone()).unwrap();

            WebsocketEntry {
                tcp_server: server,
                address: config,
                pipeline: pipeline,
                loop_time: loop_time,
            }
        }

        fn len(stream: &mut dyn AsRawFd) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn listen(&mut self) {
            for conn in self.tcp_server.incoming() {
                match conn {
                    Ok(conn) => {
                        println!("new client : {}", conn.peer_addr().unwrap());
                        let mut websocket = accept(conn.try_clone().unwrap());
                        match websocket {
                            Ok(websocket) => {
                                let mut cloned_self = self.clone();

                                let read_write_thread = thread::spawn(move || {
                                    cloned_self.handle_pipeline(websocket, conn);
                                });
                            }
                            Err(e) => {
                                println!("{}", e);
                                match e {
                                    tungstenite::HandshakeError::Interrupted(mid_handshake) => {
                                        println!("midhandshake");
                                    }
                                    tungstenite::HandshakeError::Failure(e) => {
                                        self.handle_handshake_error(e, conn);
                                    }
                                }
                            }
                        }
                    }
                    Err(e) => {
                        println!("{}", e)
                    }
                }
            }
        }
    }

    impl WebsocketEntry {
        fn handle_protocol_error(&self, error: ProtocolError, mut stream: TcpStream) {
            match error {
                tungstenite::error::ProtocolError::WrongHttpMethod => println!("WrongHttpMethod"),
                tungstenite::error::ProtocolError::WrongHttpVersion => println!("WrongHttpVersion"),
                tungstenite::error::ProtocolError::MissingConnectionUpgradeHeader => {
                    println!("MissingConnectionUpgradeHeader");
                    // let response = tungstenite::http::Response::new("Only WebSocket connections are welcome here");
                    let response = Response::builder()
                        .status(400)
                        //  .header("X-Custom-Foo", "Bar")
                        .body("Only WebSocket connections are welcome here")
                        .unwrap();
                    tungstenite::handshake::server::write_response(stream, &response).unwrap();
                }
                tungstenite::error::ProtocolError::MissingUpgradeWebSocketHeader => {
                    println!("MissingUpgradeWebSocketHeader")
                }
                tungstenite::error::ProtocolError::MissingSecWebSocketVersionHeader => {
                    println!("MissingSecWebSocketVersionHeader")
                }
                tungstenite::error::ProtocolError::MissingSecWebSocketKey => {
                    println!("MissingSecWebSocketKey")
                }
                tungstenite::error::ProtocolError::SecWebSocketAcceptKeyMismatch => {
                    println!("SecWebSocketAcceptKeyMismatch")
                }
                tungstenite::error::ProtocolError::JunkAfterRequest => println!("JunkAfterRequest"),
                tungstenite::error::ProtocolError::CustomResponseSuccessful => {
                    println!("CustomResponseSuccessful")
                }
                tungstenite::error::ProtocolError::InvalidHeader(_) => println!("InvalidHeader"),
                tungstenite::error::ProtocolError::HandshakeIncomplete => {
                    println!("HandshakeIncomplete")
                }
                tungstenite::error::ProtocolError::HttparseError(_) => println!("HttparseError"),
                tungstenite::error::ProtocolError::SendAfterClosing => println!("SendAfterClosing"),
                tungstenite::error::ProtocolError::ReceivedAfterClosing => {
                    println!("ReceivedAfterClosing")
                }
                tungstenite::error::ProtocolError::NonZeroReservedBits => {
                    println!("NonZeroReservedBits")
                }
                tungstenite::error::ProtocolError::UnmaskedFrameFromClient => {
                    println!("UnmaskedFrameFromClient")
                }
                tungstenite::error::ProtocolError::MaskedFrameFromServer => {
                    println!("MaskedFrameFromServer")
                }
                tungstenite::error::ProtocolError::FragmentedControlFrame => {
                    println!("FragmentedControlFrame")
                }
                tungstenite::error::ProtocolError::ControlFrameTooBig => {
                    println!("ControlFrameTooBig")
                }
                tungstenite::error::ProtocolError::UnknownControlFrameType(_) => {
                    println!("UnknownControlFrameType")
                }
                tungstenite::error::ProtocolError::UnknownDataFrameType(_) => {
                    println!("UnknownDataFrameType")
                }
                tungstenite::error::ProtocolError::UnexpectedContinueFrame => {
                    println!("UnexpectedContinueFrame")
                }
                tungstenite::error::ProtocolError::ExpectedFragment(_) => {
                    println!("ExpectedFragment")
                }
                tungstenite::error::ProtocolError::ResetWithoutClosingHandshake => {
                    println!("ResetWithoutClosingHandshake")
                }
                tungstenite::error::ProtocolError::InvalidOpcode(_) => println!("InvalidOpcode"),
                tungstenite::error::ProtocolError::InvalidCloseSequence => {
                    println!("InvalidCloseSequence")
                }
            }
        }

        fn handle_handshake_error(&self, error: Error, mut stream: TcpStream) {
            match error {
                tungstenite::Error::ConnectionClosed => {
                    println!("ConnectionClosed");
                }
                tungstenite::Error::AlreadyClosed => {
                    println!("AlreadyClosed");
                }
                tungstenite::Error::Io(_) => {
                    println!("Io");
                }
                tungstenite::Error::Tls(_) => {
                    println!("Tls");
                }
                tungstenite::Error::Capacity(_) => {
                    println!("Capacity");
                }
                tungstenite::Error::Protocol(protocol) => {
                    self.handle_protocol_error(protocol, stream);
                }
                tungstenite::Error::WriteBufferFull(_) => {
                    println!("WriteBufferFull");
                }
                tungstenite::Error::Utf8 => {
                    println!("Utf8");
                }
                tungstenite::Error::AttackAttempt => {
                    println!("AttackAttempt");
                }
                tungstenite::Error::Url(_) => {
                    println!("Url");
                }
                tungstenite::Error::Http(_) => {
                    println!("Http");
                }
                tungstenite::Error::HttpFormat(_) => {
                    println!("HttpFormat");
                }
            }
        }

        fn handle_pipeline_(&mut self, mut websocket: WebSocket<TcpStream>) {
            loop {
                // Read data from the WebSocket connection
                let mut msg = match websocket.read() {
                    Ok(msg) => msg,
                    Err(e) => {
                        eprintln!("Error reading WebSocket message: {}", e);
                        break;
                    }
                };

                match &mut msg {
                    Message::Text(data) => unsafe {
                        let mut vdata = vec![0; data.as_bytes().len()];
                        std::ptr::copy(
                            data.as_mut_ptr(),
                            vdata.as_mut_ptr(),
                            data.as_bytes().len(),
                        );
                        self.pipeline.write(vdata).unwrap();
                    },
                    Message::Binary(data) => unsafe {
                        let mut buf: Vec<u8> = vec![0; data.len()];
                        std::ptr::copy(data.as_mut_ptr(), buf.as_mut_ptr(), data.len());
                        self.pipeline.write(buf).unwrap();
                    },
                    Message::Ping(_) | Message::Pong(_) | Message::Close(_) | Message::Frame(_) => {
                    }
                }

                if self.pipeline.read_available() {
                    let data = self.pipeline.read().unwrap();
                    if !data.is_empty() {
                        let msg = Message::Binary(data);
                        match websocket.send(msg) {
                            Ok(_) => {}
                            Err(e) => {
                                println!("Error writing to stream: {}", e);
                                break;
                            }
                        }
                    }
                }
            }
        }

        fn handle_pipeline(&mut self, mut websocket: WebSocket<TcpStream>, mut stream: TcpStream) {
            loop {
                let len = WebsocketEntry::len(&mut stream).unwrap();
                if len > 0 {
                    match &mut websocket.read() {
                        Ok(m) => {
                            if m.len() > 0 {
                                match m {
                                    Message::Text(data) => unsafe {
                                        let mut vdata = vec![0; data.as_bytes().len()];
                                        std::ptr::copy(
                                            data.as_mut_ptr(),
                                            vdata.as_mut_ptr(),
                                            data.as_bytes().len(),
                                        );
                                        self.pipeline.write(vdata).unwrap();
                                    },
                                    Message::Binary(data) => unsafe {
                                        let mut buf: Vec<u8> = vec![0; data.len()];
                                        std::ptr::copy(
                                            data.as_mut_ptr(),
                                            buf.as_mut_ptr(),
                                            data.len(),
                                        );
                                        self.pipeline.write(buf).unwrap();
                                    },
                                    Message::Ping(_)
                                    | Message::Pong(_)
                                    | Message::Close(_)
                                    | Message::Frame(_) => {}
                                }
                            }
                        }
                        Err(e) => {
                            println!("Error reading from stream: {}", e);
                            break;
                        }
                    }
                }

                if self.pipeline.read_available() {
                    let data = self.pipeline.read().unwrap();
                    if !data.is_empty() {
                        let msg = Message::Binary(data);
                        match websocket.send(msg) {
                            Ok(_) => {}
                            Err(e) => {
                                println!("Error writing to stream: {}", e);
                                break;
                            }
                        }
                    }
                }

                std::thread::sleep(Duration::from_millis(self.loop_time));
            }
        }
    }
}



###########-websocket_step.rs-############
#[allow(non_snake_case, unused_variables, dead_code)]
pub mod ws_destination {
    use std::io::{Read, Write};
    use std::net::TcpStream;
    use std::os::fd::AsRawFd;
    use std::str::FromStr;
    use tungstenite::client::IntoClientRequest;
    use tungstenite::http::{Request, Uri};
    use tungstenite::protocol::{Role, WebSocketContext};
    use tungstenite::{client, Message, WebSocket};

    use crate::pipeline_module::pipeline::{PipelineDirection, PipelineStep};
    use crate::BoxedClone;

    pub struct WebsocketDestination {
        tcp_stream: TcpStream,
        context: WebSocketContext,
        address: String,
    }

    impl PipelineStep for WebsocketDestination {
        fn len(&self) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(self.tcp_stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn set_pipeline_direction(&mut self, direction: PipelineDirection) {
            // println!("{}", direction);
        }

        fn start(&self) {}
    }

    impl BoxedClone for WebsocketDestination {
        fn bclone(&self) -> Box<dyn PipelineStep> {
            Box::new(WebsocketDestination::new(&self.address))
        }
    }

    impl Read for WebsocketDestination {
        fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(self.tcp_stream.as_raw_fd(), libc::FIONREAD, &mut available) };

            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else if available == 0 {
                Ok(0)
            } else {
                let m = &mut self.get_websocket().read().unwrap();
                match m {
                    Message::Text(data) => unsafe {
                        std::ptr::copy(data.as_mut_ptr(), buf.as_mut_ptr(), data.as_bytes().len());
                        Ok(data.as_bytes().len())
                    },
                    Message::Binary(data) => unsafe {
                        std::ptr::copy(data.as_mut_ptr(), buf.as_mut_ptr(), data.len());
                        Ok(data.len())
                    },
                    Message::Ping(_) | Message::Pong(_) | Message::Close(_) | Message::Frame(_) => {
                        Ok(0)
                    }
                }
            }
        }
    }

    impl Write for WebsocketDestination {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let vec = Vec::from(buf);
            let msg = Message::Binary(vec);
            let result = self.get_websocket().send(msg);
            match result {
                Ok(_) => {
                    Ok(buf.len())},
                Err(error) => {
                    panic!("{}", error);
                }
            }
        }

        fn flush(&mut self) -> std::io::Result<()> {
            self.get_websocket().flush().unwrap();
            Ok(())
        }
    }

    #[allow(unreachable_code)]
    impl WebsocketDestination {
        pub fn new(address: &str) -> Self {
            let uri: Uri = address.parse::<Uri>().unwrap();
            let mut addr = String::from(uri.host().unwrap());
            let mut port = 0;
            if uri.port() != None {
                port = uri.port().unwrap().as_u16();
            } else {
                port = match uri.scheme_str() {
                    Some("ws") => 80,
                    Some("wss") => 443,
                    Some("http") => 80,
                    Some("https") => 443,
                    None | _ => {
                        panic!("unknow uri scheme")
                    }
                };
            }

            addr.push_str(":");
            addr.push_str(port.to_string().as_str());
            let connection = TcpStream::connect(addr).unwrap();
            let req: tungstenite::http::Request<()> = uri.into_client_request().unwrap();
            let l = client(req, connection.try_clone().unwrap()).unwrap();

            //handle errors
            WebsocketDestination {
                tcp_stream: connection,
                context: WebSocketContext::new(Role::Client, None),
                address: String::from_str(address).unwrap(),
            }
        }

        pub fn get_websocket(&self) -> WebSocket<TcpStream> {
            WebSocket::from_raw_socket(self.tcp_stream.try_clone().unwrap(), Role::Client, None)
        }
    }
}

pub mod wss_destination {
    use core::panic;
    use openssl::ssl::{SslConnector, SslConnectorBuilder, SslMethod, SslStream};
    use std::io::{Read, Write};
    use std::net::TcpStream;
    use std::os::fd::AsRawFd;
    use std::str::FromStr;
    use tungstenite::client::IntoClientRequest;
    use tungstenite::http::{HeaderName, Request, Uri};
    use tungstenite::protocol::{Role, WebSocketContext};
    use tungstenite::{client, Message, WebSocket};

    use crate::{BoxedClone, PipelineStep};

    pub struct WssDestination {
        tcp_stream: TcpStream,
        ssl_stream: WebSocket<SslStream<TcpStream>>,
        context: WebSocketContext,
        address: String,
    }

    impl WssDestination {
        pub fn new(address: &str) -> WssDestination {
            let uri: Uri = address.parse::<Uri>().unwrap();
            let mut addr = String::from(uri.host().unwrap());
            let mut port = 0;
            if uri.port() != None {
                port = uri.port().unwrap().as_u16();
            } else {
                port = match uri.scheme_str() {
                    Some("ws") => 80,
                    Some("wss") => 443,
                    Some("http") => 80,
                    Some("https") => 443,
                    None | _ => {
                        panic!("unknow uri scheme")
                    }
                };
            }

            addr.push_str(":");
            addr.push_str(port.to_string().as_str());
            let connection = TcpStream::connect(addr.clone()).unwrap();

            #[cfg(feature = "ubuntu-22")]
            let mut ssl_connector_builder: SslConnectorBuilder =
                SslConnector::ConnectConfigurationbuilder(SslMethod::tls()).unwrap();
            #[cfg(feature = "ubuntu-20")]
                let mut ssl_connector_builder: SslConnectorBuilder =
                    SslConnector::builder(SslMethod::tls()).unwrap();

            // ssl_connector_builder.set_verify(SslVerifyMode::NONE);
            // ssl_connector_builder.set_verify_callback(SslVerifyMode::NONE, |r, context|{
            //     true
            // });
            // ssl_connector_builder.set_verify_callback(SslVerifyMode::PEER, |r, context|{
            //     true
            // });

            let mut ssl_connector = ssl_connector_builder.build();
            let ssl_connection = ssl_connector
                .configure()
                .unwrap()
                // .verify_hostname(false)
                // .use_server_name_indication(false)
                .connect(uri.host().unwrap(), connection.try_clone().unwrap())
                .unwrap();

            let req: tungstenite::http::Request<()> = uri.into_client_request().unwrap();
            // let r = ssl_connection.get_mut();
            let (socket, _response) = client(req, ssl_connection).unwrap();

            Self {
                ssl_stream: socket,
                tcp_stream: connection,
                context: WebSocketContext::new(Role::Client, None),
                address: String::from_str(address).unwrap(),
            }
        }

        pub fn get_websocket(&mut self) -> WebSocket<&mut SslStream<TcpStream>> {
            WebSocket::from_raw_socket(self.ssl_stream.get_mut(), Role::Client, None)
        }
    }

    impl PipelineStep for WssDestination {
        fn len(&self) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(self.tcp_stream.as_raw_fd(), libc::FIONREAD, &mut available) };
            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else {
                Ok(available)
            }
        }

        fn set_pipeline_direction(&mut self, direction: crate::PipelineDirection) {}

        fn start(&self) {}
    }

    impl BoxedClone for WssDestination {
        fn bclone(&self) -> Box<dyn PipelineStep> {
            Box::new(WssDestination::new(&self.address))
        }
    }

    impl Read for WssDestination {
        fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
            let mut available: usize = 0;
            let result: i32 =
                unsafe { libc::ioctl(self.tcp_stream.as_raw_fd(), libc::FIONREAD, &mut available) };

            if result == -1 {
                let errno = std::io::Error::last_os_error();
                Err(errno)
            } else if available == 0 {
                Ok(0)
            } else {
                let m = &mut self.get_websocket().read().unwrap();
                // let mut m = &mut self
                //     .context
                //     .read::<TcpStream>(&mut self.tcp_stream)
                //     .unwrap();
                match m {
                    Message::Text(data) => unsafe {
                        std::ptr::copy(data.as_mut_ptr(), buf.as_mut_ptr(), data.as_bytes().len());
                        Ok(data.as_bytes().len())
                    },
                    Message::Binary(data) => unsafe {
                        std::ptr::copy(data.as_mut_ptr(), buf.as_mut_ptr(), data.len());
                        Ok(data.len())
                    },
                    Message::Ping(_) | Message::Pong(_) | Message::Close(_) | Message::Frame(_) => {
                        Ok(0)
                    }
                }
                // self.tcp_stream.read(buf)
            }
        }
    }

    impl Write for WssDestination {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let vec = Vec::from(buf);
            let msg = Message::Binary(vec);
            let result = self.get_websocket().send(msg);
            match result {
                Ok(_) => Ok(buf.len()),
                Err(error) => {
                    panic!("{}", error);
                }
            }
        }

        fn flush(&mut self) -> std::io::Result<()> {
            self.get_websocket().flush().unwrap();
            Ok(())
        }
    }
}



